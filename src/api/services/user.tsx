import { AxiosError } from 'axios';
import { apiPrivate, apiPublic } from '../api'; 
import { UserPath } from '../enums/routes'
import { UserDto } from '../models/user';

// ‚úÖ Registro de Paciente
export async function registerPatient(request: UserDto.RegisterPatient): Promise<UserDto.RegisterPatientResponse> {
    try {
        console.log('[UserService] üë§ Registrando paciente...');
        console.log('[UserService] üìù Dados do paciente:', JSON.stringify(request, null, 2));
        
        const { data: response } = await apiPublic.post<UserDto.RegisterPatientResponse>(
            UserPath.REGISTER_PATIENT, 
            request,
            {
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'ngrok-skip-browser-warning': 'true',
                },
                timeout: 30000
            }
        );
        
        console.log('[UserService] ‚úÖ Paciente registrado com sucesso');
        console.log('[UserService] üìÑ Resposta:', response);
        return response;
        
    } catch (error: any) {
        console.error('[UserService] ‚ùå Erro no registro de paciente:', error);
        
        if (error instanceof AxiosError) {
            const status = error.response?.status;
            const responseData = error.response?.data;
            
            console.error('[UserService] ‚ùå Status:', status);
            console.error('[UserService] ‚ùå Dados do erro:', responseData);
            
            // Tratar erros espec√≠ficos
            let errorMessage = 'Erro no registro do paciente.';
            
            switch (status) {
                case 400:
                    if (responseData?.errors) {
                        // Tratar erros de valida√ß√£o espec√≠ficos
                        const errors = responseData.errors;
                        let specificErrors = [];
                        
                        Object.keys(errors).forEach(field => {
                            if (Array.isArray(errors[field])) {
                                specificErrors.push(`${field}: ${errors[field][0]}`);
                            }
                        });
                        
                        errorMessage = specificErrors.length > 0 ? specificErrors.join('\n') : 'Dados inv√°lidos fornecidos.';
                    } else {
                        errorMessage = responseData?.message || responseData?.title || 'Dados inv√°lidos fornecidos.';
                    }
                    break;
                case 409:
                    errorMessage = 'Email ou CPF j√° cadastrado no sistema.';
                    break;
                case 422:
                    errorMessage = 'Dados n√£o process√°veis. Verifique as informa√ß√µes.';
                    break;
                case 500:
                    errorMessage = 'Erro interno do servidor. Tente novamente mais tarde.';
                    break;
                default:
                    errorMessage = responseData?.message || responseData?.title || `Erro ${status}: Falha na comunica√ß√£o com o servidor.`;
            }
            
            throw new Error(errorMessage);
            
        } else if (error.request) {
            // Erro de rede
            console.error('[UserService] ‚ùå Erro de rede');
            throw new Error('Erro de conex√£o. Verifique sua internet e tente novamente.');
            
        } else {
            // Erro de configura√ß√£o
            console.error('[UserService] ‚ùå Erro de configura√ß√£o:', error.message);
            throw new Error('Erro interno. Tente novamente.');
        }
    }
}

// ‚úÖ Registro de M√©dico - Usando tipo correto
export async function registerDoctor(request: UserDto.RegisterDoctor): Promise<UserDto.RegisterPatientResponse> {
    try {
        console.log('[UserService] ü©∫ Registrando m√©dico...');
        console.log('[UserService] üìù Dados do m√©dico:', JSON.stringify(request, null, 2));
        
        const { data: response } = await apiPublic.post<UserDto.RegisterPatientResponse>(
            UserPath.REGISTER_DOCTOR, 
            request,
            {
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'ngrok-skip-browser-warning': 'true',
                },
                timeout: 30000
            }
        );
        
        console.log('[UserService] ‚úÖ M√©dico registrado com sucesso');
        console.log('[UserService] üìÑ Resposta:', response);
        return response;
        
    } catch (error: any) {
        console.error('[UserService] ‚ùå Erro no registro de m√©dico:', error);
        
        if (error instanceof AxiosError) {
            const status = error.response?.status;
            const responseData = error.response?.data;
            
            console.error('[UserService] ‚ùå Status:', status);
            console.error('[UserService] ‚ùå Dados do erro:', responseData);
            
            // Tratar erros espec√≠ficos
            let errorMessage = 'Erro no registro m√©dico.';
            
            switch (status) {
                case 400:
                    if (responseData?.errors) {
                        // Tratar erros de valida√ß√£o espec√≠ficos da API
                        const errors = responseData.errors;
                        let specificErrors = [];
                        
                        Object.keys(errors).forEach(field => {
                            if (Array.isArray(errors[field])) {
                                specificErrors.push(`${field}: ${errors[field][0]}`);
                            }
                        });
                        
                        errorMessage = specificErrors.length > 0 ? specificErrors.join('\n') : 'Dados inv√°lidos fornecidos.';
                    } else {
                        errorMessage = responseData?.message || responseData?.title || 'Dados inv√°lidos fornecidos.';
                    }
                    break;
                case 409:
                    errorMessage = 'Email, CPF ou CRM j√° cadastrado no sistema.';
                    break;
                case 422:
                    errorMessage = 'Dados n√£o process√°veis. Verifique as informa√ß√µes.';
                    break;
                case 500:
                    errorMessage = 'Erro interno do servidor. Tente novamente mais tarde.';
                    break;
                default:
                    errorMessage = responseData?.message || responseData?.title || `Erro ${status}: Falha na comunica√ß√£o com o servidor.`;
            }
            
            throw new Error(errorMessage);
            
        } else if (error.request) {
            // Erro de rede
            console.error('[UserService] ‚ùå Erro de rede');
            throw new Error('Erro de conex√£o. Verifique sua internet e tente novamente.');
            
        } else {
            // Erro de configura√ß√£o
            console.error('[UserService] ‚ùå Erro de configura√ß√£o:', error.message);
            throw new Error('Erro interno. Tente novamente.');
        }
    }
}

// ‚úÖ Buscar usu√°rio por email
export async function getUserByEmail(email: string): Promise<UserDto.UserResponse> {
    try {
        console.log('[UserService] üîç Buscando usu√°rio por email:', email);
        
        const { data: response } = await apiPrivate.get<UserDto.UserResponse>(
            `${UserPath.GET_USER_BY_EMAIL}?email=${encodeURIComponent(email)}`,
            {
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0',
                }
            }
        );
        
        console.log('[UserService] ‚úÖ Usu√°rio encontrado');
        return response;
        
    } catch (error: any) {
        console.error('[UserService] ‚ùå Erro ao buscar usu√°rio:', error);
        
        if (error instanceof AxiosError) {
            const status = error.response?.status;
            const responseData = error.response?.data;
            
            let errorMessage = 'N√£o foi poss√≠vel buscar o usu√°rio.';
            
            switch (status) {
                case 404:
                    errorMessage = 'Usu√°rio n√£o encontrado.';
                    break;
                case 400:
                    errorMessage = 'Email inv√°lido fornecido.';
                    break;
                case 401:
                    errorMessage = 'Acesso negado. Fa√ßa login novamente.';
                    break;
                case 500:
                    errorMessage = 'Erro interno do servidor.';
                    break;
                default:
                    errorMessage = responseData?.title || responseData?.message || 'Erro ao buscar usu√°rio.';
            }
            
            throw new Error(errorMessage);
        } else {
            console.error('[UserService] ‚ùå Erro inesperado ao buscar usu√°rio:', error);
            throw new Error('Ocorreu um erro inesperado.');
        }
    }
}

// ‚úÖ Deletar usu√°rio por email
export async function deleteUserByEmail(email: string): Promise<void> {
    try {
        console.log('[UserService] üóëÔ∏è Deletando usu√°rio por email:', email);
        
        await apiPrivate.delete(
            `${UserPath.DELETE_USER_BY_EMAIL}?email=${encodeURIComponent(email)}`,
            {
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0',
                }
            }
        );
        
        console.log('[UserService] ‚úÖ Usu√°rio deletado com sucesso');
        
    } catch (error: any) {
        console.error('[UserService] ‚ùå Erro ao deletar usu√°rio:', error);
        
        if (error instanceof AxiosError) {
            const status = error.response?.status;
            const responseData = error.response?.data;
            
            let errorMessage = 'N√£o foi poss√≠vel deletar o usu√°rio.';
            
            switch (status) {
                case 404:
                    errorMessage = 'Usu√°rio n√£o encontrado para deletar.';
                    break;
                case 403:
                    errorMessage = 'Voc√™ n√£o tem permiss√£o para deletar este usu√°rio.';
                    break;
                case 401:
                    errorMessage = 'Acesso negado. Fa√ßa login novamente.';
                    break;
                case 409:
                    errorMessage = 'Usu√°rio n√£o pode ser deletado (possui agendamentos ativos).';
                    break;
                case 500:
                    errorMessage = 'Erro interno do servidor.';
                    break;
                default:
                    errorMessage = responseData?.title || responseData?.message || 'Erro ao deletar usu√°rio.';
            }
            
            throw new Error(errorMessage);
        } else {
            console.error('[UserService] ‚ùå Erro inesperado ao deletar usu√°rio:', error);
            throw new Error('Ocorreu um erro inesperado.');
        }
    }
}